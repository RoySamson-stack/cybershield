"""ML service for learning threat patterns from malware samples"""
import logging
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from django.utils import timezone
from django.db.models import Count, Q
from collections import Counter
from .models import (
    MalwareSample,
    BehavioralAnalysis,
    ThreatPattern,
    ThreatIntelligence
)

logger = logging.getLogger(__name__)


class ThreatPatternLearningService:
    """ML service for learning threat patterns from collected samples"""
    
    def __init__(self):
        """Initialize pattern learning service"""
        pass
    
    def learn_patterns(self, days: int = 30) -> List[ThreatPattern]:
        """Learn patterns from recent malware samples"""
        cutoff_date = timezone.now() - timedelta(days=days)
        
        # Get analyzed samples
        samples = MalwareSample.objects.filter(
            is_malicious=True,
            analyzed_at__gte=cutoff_date
        ).select_related('behavioral_analysis', 'virustotal_analysis')
        
        patterns = []
        
        # Pattern 1: Behavioral patterns
        behavioral_patterns = self._learn_behavioral_patterns(samples)
        patterns.extend(behavioral_patterns)
        
        # Pattern 2: Network patterns
        network_patterns = self._learn_network_patterns(samples)
        patterns.extend(network_patterns)
        
        # Pattern 3: File operation patterns
        file_patterns = self._learn_file_patterns(samples)
        patterns.extend(file_patterns)
        
        # Pattern 4: IOC patterns
        ioc_patterns = self._learn_ioc_patterns(samples)
        patterns.extend(ioc_patterns)
        
        # Pattern 5: Family-specific patterns
        family_patterns = self._learn_family_patterns(samples)
        patterns.extend(family_patterns)
        
        return patterns
    
    def _learn_behavioral_patterns(self, samples) -> List[ThreatPattern]:
        """Learn behavioral patterns from samples"""
        patterns = []
        
        # Group samples by common behaviors
        behavior_groups = {}
        
        for sample in samples:
            if not hasattr(sample, 'behavioral_analysis'):
                continue
            
            behavior = sample.behavioral_analysis
            
            # Create behavior signature
            signature = {
                'files_created_count': len(behavior.files_created),
                'network_connections_count': len(behavior.network_connections),
                'domains_count': len(behavior.domains_contacted),
                'processes_count': len(behavior.processes_created),
            }
            
            sig_key = str(sorted(signature.items()))
            
            if sig_key not in behavior_groups:
                behavior_groups[sig_key] = {
                    'samples': [],
                    'signature': signature
                }
            behavior_groups[sig_key]['samples'].append(sample)
        
        # Create patterns for groups with 3+ samples
        for sig_key, group in behavior_groups.items():
            if len(group['samples']) >= 3:
                pattern = self._create_behavioral_pattern(group)
                if pattern:
                    patterns.append(pattern)
        
        return patterns
    
    def _learn_network_patterns(self, samples) -> List[ThreatPattern]:
        """Learn network communication patterns"""
        patterns = []
        
        # Collect all network data
        domains = []
        ports = []
        protocols = []
        
        for sample in samples:
            if hasattr(sample, 'behavioral_analysis'):
                behavior = sample.behavioral_analysis
                domains.extend(behavior.domains_contacted)
                
                for conn in behavior.network_connections:
                    ports.append(conn.get('port'))
                    protocols.append(conn.get('protocol'))
        
        # Find common patterns
        domain_counter = Counter(domains)
        port_counter = Counter(ports)
        protocol_counter = Counter(protocols)
        
        # Create pattern for frequently contacted domains
        for domain, count in domain_counter.most_common(10):
            if count >= 3:
                pattern, _ = ThreatPattern.objects.update_or_create(
                    pattern_name=f"Frequent Domain Contact: {domain}",
                    pattern_type='ioc',
                    defaults={
                        'description': f"Multiple samples ({count}) contacted domain {domain}",
                        'indicators': {'domains': [domain]},
                        'confidence_score': min(1.0, count / 10.0),
                        'sample_count': count,
                        'severity': 'high' if count >= 10 else 'medium',
                        'is_trending': count >= 5,
                    }
                )
                patterns.append(pattern)
        
        return patterns
    
    def _learn_file_patterns(self, samples) -> List[ThreatPattern]:
        """Learn file operation patterns"""
        patterns = []
        
        file_extensions = []
        file_paths = []
        
        for sample in samples:
            if hasattr(sample, 'behavioral_analysis'):
                behavior = sample.behavioral_analysis
                
                # Analyze created files
                for file_path in behavior.files_created:
                    if '.' in file_path:
                        ext = file_path.split('.')[-1].lower()
                        file_extensions.append(ext)
                    file_paths.append(file_path)
        
        # Find common file operations
        ext_counter = Counter(file_extensions)
        
        for ext, count in ext_counter.most_common(5):
            if count >= 3:
                pattern, _ = ThreatPattern.objects.update_or_create(
                    pattern_name=f"File Creation Pattern: .{ext}",
                    pattern_type='behavior',
                    defaults={
                        'description': f"Multiple samples ({count}) create .{ext} files",
                        'indicators': {'file_extensions': [ext]},
                        'confidence_score': min(1.0, count / 10.0),
                        'sample_count': count,
                        'severity': 'medium',
                    }
                )
                patterns.append(pattern)
        
        return patterns
    
    def _learn_ioc_patterns(self, samples) -> List[ThreatPattern]:
        """Learn IOC patterns"""
        patterns = []
        
        # Collect IOCs
        all_iocs = {
            'domains': [],
            'ips': [],
            'hashes': []
        }
        
        for sample in samples:
            if hasattr(sample, 'behavioral_analysis'):
                behavior = sample.behavioral_analysis
                all_iocs['domains'].extend(behavior.domains_contacted)
                all_iocs['ips'].extend([
                    conn.get('ip') for conn in behavior.network_connections
                    if conn.get('ip')
                ])
            
            all_iocs['hashes'].append(sample.sha256_hash)
        
        # Find shared IOCs (indicating same campaign)
        domain_counter = Counter(all_iocs['domains'])
        ip_counter = Counter(all_iocs['ips'])
        
        # Create pattern for shared domains
        shared_domains = [d for d, c in domain_counter.items() if c >= 3]
        if shared_domains:
            pattern, _ = ThreatPattern.objects.update_or_create(
                pattern_name=f"Shared IOC Pattern: {len(shared_domains)} domains",
                pattern_type='ioc',
                defaults={
                    'description': f"Multiple samples share {len(shared_domains)} domains",
                    'indicators': {'domains': shared_domains[:10]},
                    'confidence_score': min(1.0, len(shared_domains) / 5.0),
                    'sample_count': len(shared_domains),
                    'severity': 'high',
                    'is_trending': len(shared_domains) >= 5,
                }
            )
            patterns.append(pattern)
        
        return patterns
    
    def _learn_family_patterns(self, samples) -> List[ThreatPattern]:
        """Learn patterns specific to malware families"""
        patterns = []
        
        # Group by family
        families = {}
        for sample in samples:
            family = sample.threat_family or 'Unknown'
            if family not in families:
                families[family] = []
            families[family].append(sample)
        
        # Create pattern for each family with 3+ samples
        for family, family_samples in families.items():
            if len(family_samples) >= 3 and family != 'Unknown':
                # Analyze common characteristics
                common_behaviors = self._extract_common_behaviors(family_samples)
                
                pattern, _ = ThreatPattern.objects.update_or_create(
                    pattern_name=f"{family} Family Pattern",
                    pattern_type='family',
                    defaults={
                        'description': f"Pattern identified in {len(family_samples)} {family} samples",
                        'indicators': common_behaviors,
                        'confidence_score': min(1.0, len(family_samples) / 20.0),
                        'sample_count': len(family_samples),
                        'severity': 'high' if len(family_samples) >= 10 else 'medium',
                        'is_trending': len(family_samples) >= 5,
                    }
                )
                patterns.append(pattern)
        
        return patterns
    
    def _extract_common_behaviors(self, samples: List[MalwareSample]) -> Dict:
        """Extract common behaviors from samples"""
        behaviors = {
            'common_domains': [],
            'common_ports': [],
            'common_file_ops': []
        }
        
        domains = []
        ports = []
        
        for sample in samples:
            if hasattr(sample, 'behavioral_analysis'):
                behavior = sample.behavioral_analysis
                domains.extend(behavior.domains_contacted)
                
                for conn in behavior.network_connections:
                    ports.append(conn.get('port'))
        
        behaviors['common_domains'] = list(set(domains))[:10]
        behaviors['common_ports'] = list(set(ports))[:10]
        
        return behaviors
    
    def _create_behavioral_pattern(self, group: Dict) -> Optional[ThreatPattern]:
        """Create a behavioral pattern from a group of samples"""
        try:
            samples = group['samples']
            signature = group['signature']
            
            pattern_name = f"Behavioral Pattern: {signature['files_created_count']} files, {signature['network_connections_count']} connections"
            
            pattern, _ = ThreatPattern.objects.update_or_create(
                pattern_name=pattern_name,
                pattern_type='behavior',
                defaults={
                    'description': f"Pattern observed in {len(samples)} samples",
                    'indicators': signature,
                    'confidence_score': min(1.0, len(samples) / 10.0),
                    'sample_count': len(samples),
                    'severity': 'medium',
                }
            )
            
            return pattern
            
        except Exception as e:
            logger.error(f"Error creating behavioral pattern: {e}")
            return None
    
    def update_trends(self):
        """Update trending patterns based on recent activity"""
        # Get patterns seen in last 7 days
        recent_date = timezone.now() - timedelta(days=7)
        
        patterns = ThreatPattern.objects.filter(
            last_seen__gte=recent_date
        )
        
        for pattern in patterns:
            # Calculate trend score based on detection frequency
            recent_detections = pattern.sample_count
            
            # Update trending status
            pattern.is_trending = recent_detections >= 5
            pattern.trend_score = min(1.0, recent_detections / 20.0)
            pattern.save()






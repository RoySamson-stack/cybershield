"""Malware analysis services - VirusTotal integration and behavioral analysis"""
import requests
import hashlib
import logging
import json
from typing import Dict, Optional, List
from django.conf import settings
from django.utils import timezone
from datetime import datetime, timedelta
from .models import (
    MalwareSample,
    VirusTotalAnalysis,
    BehavioralAnalysis,
    ThreatPattern,
    ThreatIntelligence
)

logger = logging.getLogger(__name__)


class VirusTotalService:
    """Service for VirusTotal API integration"""
    
    API_BASE = "https://www.virustotal.com/vtapi/v2"
    
    def __init__(self, api_key: Optional[str] = None):
        """Initialize with VirusTotal API key"""
        self.api_key = api_key or getattr(settings, 'VIRUSTOTAL_API_KEY', None)
        if not self.api_key:
            logger.warning("VirusTotal API key not configured")
        
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'CyberShield/1.0'
        })
    
    def scan_file(self, file_path: str, file_content: bytes) -> Dict:
        """Submit file to VirusTotal for scanning"""
        if not self.api_key:
            return {'error': 'VirusTotal API key not configured'}
        
        try:
            files = {'file': (file_path, file_content)}
            params = {'apikey': self.api_key}
            
            response = self.session.post(
                f"{self.API_BASE}/file/scan",
                files=files,
                params=params,
                timeout=30
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                logger.error(f"VirusTotal scan failed: {response.status_code}")
                return {'error': f'HTTP {response.status_code}'}
                
        except Exception as e:
            logger.error(f"Error scanning file with VirusTotal: {e}")
            return {'error': str(e)}
    
    def get_file_report(self, resource_hash: str) -> Dict:
        """Get file report from VirusTotal using hash (MD5, SHA1, or SHA256)"""
        if not self.api_key:
            return {'error': 'VirusTotal API key not configured'}
        
        try:
            params = {
                'apikey': self.api_key,
                'resource': resource_hash
            }
            
            response = self.session.get(
                f"{self.API_BASE}/file/report",
                params=params,
                timeout=30
            )
            
            if response.status_code == 200:
                return response.json()
            elif response.status_code == 204:
                return {'error': 'Rate limit exceeded'}
            else:
                logger.error(f"VirusTotal report failed: {response.status_code}")
                return {'error': f'HTTP {response.status_code}'}
                
        except Exception as e:
            logger.error(f"Error getting VirusTotal report: {e}")
            return {'error': str(e)}
    
    def analyze_sample(self, sample: MalwareSample) -> Optional[VirusTotalAnalysis]:
        """Analyze a malware sample using VirusTotal"""
        if not self.api_key:
            logger.warning("VirusTotal API key not configured, skipping analysis")
            return None
        
        try:
            # Get report using SHA256 hash
            report = self.get_file_report(sample.sha256_hash)
            
            if 'error' in report:
                logger.error(f"VirusTotal error for sample {sample.id}: {report['error']}")
                return None
            
            # Check if scan is complete
            if report.get('response_code') == 1:
                # Scan complete
                positives = report.get('positives', 0)
                total = report.get('total', 0)
                
                # Create or update analysis
                analysis, created = VirusTotalAnalysis.objects.update_or_create(
                    sample=sample,
                    defaults={
                        'scan_id': report.get('scan_id'),
                        'permalink': report.get('permalink'),
                        'positives': positives,
                        'total_engines': total,
                        'detection_ratio': (positives / total * 100) if total > 0 else 0,
                        'engine_results': report.get('scans', {}),
                        'scan_date': self._parse_datetime(report.get('scan_date')),
                        'first_seen': self._parse_datetime(report.get('first_seen')),
                        'last_seen': self._parse_datetime(report.get('last_seen')),
                        'additional_info': {
                            'md5': report.get('md5'),
                            'sha1': report.get('sha1'),
                            'sha256': report.get('sha256'),
                            'type': report.get('type'),
                            'type_description': report.get('type_description'),
                            'tags': report.get('tags', []),
                        }
                    }
                )
                
                # Update sample threat score
                if positives > 0:
                    sample.is_malicious = True
                    sample.threat_score = min(100, int((positives / total) * 100))
                    sample.threat_family = self._extract_threat_family(report)
                    sample.save()
                
                return analysis
            elif report.get('response_code') == 0:
                # File not found, submit for scanning
                logger.info(f"Submitting sample {sample.id} to VirusTotal")
                scan_result = self.scan_file(sample.file_name, b'')  # Would need actual file content
                return None
            else:
                logger.warning(f"Unexpected response_code: {report.get('response_code')}")
                return None
                
        except Exception as e:
            logger.error(f"Error analyzing sample {sample.id} with VirusTotal: {e}")
            return None
    
    def _parse_datetime(self, timestamp: Optional[str]) -> Optional[datetime]:
        """Parse VirusTotal timestamp"""
        if not timestamp:
            return None
        try:
            return datetime.fromtimestamp(int(timestamp))
        except:
            return None
    
    def _extract_threat_family(self, report: Dict) -> Optional[str]:
        """Extract threat family from VirusTotal report"""
        # Check engine results for common family names
        scans = report.get('scans', {})
        families = []
        
        for engine, result in scans.items():
            if result.get('detected'):
                result_str = result.get('result', '')
                # Common family patterns
                if any(family in result_str for family in ['Trojan', 'Ransomware', 'Worm', 'Virus']):
                    families.append(result_str)
        
        if families:
            # Return most common
            return max(set(families), key=families.count)
        return None


class BehavioralAnalysisService:
    """Service for behavioral analysis of malware samples"""
    
    def __init__(self):
        """Initialize behavioral analysis service"""
        pass
    
    def analyze_sample(self, sample: MalwareSample, sandbox_results: Optional[Dict] = None) -> BehavioralAnalysis:
        """Perform behavioral analysis on a sample"""
        # In production, this would integrate with sandbox environments
        # like Cuckoo Sandbox, Joe Sandbox, or custom analysis
        
        analysis_data = {
            'files_created': [],
            'files_modified': [],
            'network_connections': [],
            'dns_queries': [],
            'processes_created': [],
            'iocs': {}
        }
        
        # If sandbox results provided, extract from them
        if sandbox_results:
            analysis_data = self._extract_from_sandbox(sandbox_results)
        
        # Create behavioral analysis record
        analysis, created = BehavioralAnalysis.objects.update_or_create(
            sample=sample,
            defaults={
                'files_created': analysis_data.get('files_created', []),
                'files_modified': analysis_data.get('files_modified', []),
                'files_deleted': analysis_data.get('files_deleted', []),
                'files_read': analysis_data.get('files_read', []),
                'network_connections': analysis_data.get('network_connections', []),
                'dns_queries': analysis_data.get('dns_queries', []),
                'domains_contacted': analysis_data.get('domains_contacted', []),
                'processes_created': analysis_data.get('processes_created', []),
                'iocs': analysis_data.get('iocs', {}),
                'analysis_tool': 'cybershield',
            }
        )
        
        return analysis
    
    def _extract_from_sandbox(self, sandbox_results: Dict) -> Dict:
        """Extract behavioral data from sandbox results"""
        # Placeholder - would parse actual sandbox output
        return {
            'files_created': sandbox_results.get('files_created', []),
            'network_connections': sandbox_results.get('network', {}).get('connections', []),
            'dns_queries': sandbox_results.get('network', {}).get('dns', []),
            'iocs': sandbox_results.get('iocs', {}),
        }


class ThreatIntelligenceService:
    """Service for generating threat intelligence from collected data"""
    
    def __init__(self):
        """Initialize threat intelligence service"""
        pass
    
    def generate_intelligence(self, days: int = 7) -> List[ThreatIntelligence]:
        """Generate threat intelligence from recent samples"""
        cutoff_date = timezone.now() - timedelta(days=days)
        
        # Get recent malicious samples
        recent_samples = MalwareSample.objects.filter(
            is_malicious=True,
            analyzed_at__gte=cutoff_date
        )
        
        # Group by threat family
        families = {}
        for sample in recent_samples:
            family = sample.threat_family or 'Unknown'
            if family not in families:
                families[family] = []
            families[family].append(sample)
        
        intelligence_items = []
        
        # Generate intelligence for each family
        for family, samples in families.items():
            if len(samples) >= 3:  # Only create intelligence for families with 3+ samples
                intelligence = self._create_intelligence_item(family, samples)
                if intelligence:
                    intelligence_items.append(intelligence)
        
        return intelligence_items
    
    def _create_intelligence_item(self, family: str, samples: List[MalwareSample]) -> Optional[ThreatIntelligence]:
        """Create a threat intelligence item from samples"""
        try:
            # Aggregate IOCs
            all_iocs = {
                'hashes': [],
                'domains': [],
                'ips': [],
                'file_names': []
            }
            
            techniques = []
            detection_timeline = []
            
            for sample in samples:
                all_iocs['hashes'].append(sample.sha256_hash)
                all_iocs['file_names'].append(sample.file_name)
                
                # Get behavioral data if available
                if hasattr(sample, 'behavioral_analysis'):
                    behavior = sample.behavioral_analysis
                    all_iocs['domains'].extend(behavior.domains_contacted)
                    all_iocs['ips'].extend([
                        conn.get('ip') for conn in behavior.network_connections
                        if conn.get('ip')
                    ])
                
                # Get VirusTotal data if available
                if hasattr(sample, 'virustotal_analysis'):
                    vt = sample.virustotal_analysis
                    if vt.additional_info.get('tags'):
                        techniques.extend(vt.additional_info['tags'])
                
                detection_timeline.append({
                    'date': sample.analyzed_at.isoformat() if sample.analyzed_at else sample.submitted_at.isoformat(),
                    'threat_score': sample.threat_score
                })
            
            # Deduplicate
            all_iocs['hashes'] = list(set(all_iocs['hashes']))
            all_iocs['domains'] = list(set(all_iocs['domains']))
            all_iocs['ips'] = list(set(all_iocs['ips']))
            techniques = list(set(techniques))
            
            # Calculate severity
            avg_score = sum(s.threat_score for s in samples) / len(samples)
            if avg_score >= 80:
                severity = 'critical'
            elif avg_score >= 60:
                severity = 'high'
            elif avg_score >= 40:
                severity = 'medium'
            else:
                severity = 'low'
            
            # Create intelligence item
            intelligence, created = ThreatIntelligence.objects.update_or_create(
                title=f"{family} Threat Activity - {timezone.now().strftime('%Y-%m-%d')}",
                defaults={
                    'description': f"Analysis of {len(samples)} {family} samples detected in the last 7 days",
                    'summary': f"Active {family} campaign detected with {len(samples)} samples",
                    'threat_type': family,
                    'threat_family': family,
                    'severity': severity,
                    'iocs': all_iocs,
                    'techniques': techniques[:10],  # Top 10 techniques
                    'detection_timeline': sorted(detection_timeline, key=lambda x: x['date']),
                    'ml_insights': {
                        'sample_count': len(samples),
                        'avg_threat_score': avg_score,
                        'trend': 'increasing' if len(samples) > 5 else 'stable'
                    },
                    'requires_pro_tier': True,
                }
            )
            
            # Add related samples
            intelligence.related_samples.set(samples)
            
            return intelligence
            
        except Exception as e:
            logger.error(f"Error creating intelligence item: {e}")
            return None








